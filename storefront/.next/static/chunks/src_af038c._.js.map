{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/utils.ts"],"sourcesContent":["import { ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,8JAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,wIAAA,CAAA,OAAI,AAAD,EAAE;AACtB"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 26, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/customer.ts"],"sourcesContent":["\"use server\"\n\nimport { sdk } from \"../config\"\nimport { HttpTypes } from \"@medusajs/types\"\nimport { revalidateTag } from \"next/cache\"\nimport { redirect } from \"next/navigation\"\nimport {\n  getAuthHeaders,\n  getCacheOptions,\n  getCacheTag,\n  getCartId,\n  removeAuthToken,\n  removeCartId,\n  setAuthToken,\n} from \"./cookies\"\n\nexport const retrieveCustomer =\n  async (): Promise<HttpTypes.StoreCustomer | null> => {\n    const authHeaders = await getAuthHeaders()\n\n    if (!authHeaders) return null\n\n    const headers = {\n      ...authHeaders,\n    }\n\n    const next = {\n      ...(await getCacheOptions(\"customers\")),\n    }\n\n    return await sdk.client\n      .fetch<{ customer: HttpTypes.StoreCustomer }>(`/store/customers/me`, {\n        method: \"GET\",\n        query: {\n          fields: \"*orders\",\n        },\n        headers,\n        next,\n        cache: \"force-cache\",\n      })\n      .then(({ customer }) => customer)\n      .catch(() => null)\n  }\n\nexport const updateCustomer = async (body: HttpTypes.StoreUpdateCustomer) => {\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  const updateRes = await sdk.store.customer\n    .update(body, {}, headers)\n    .then(({ customer }) => customer)\n    .catch((err) => {\n      throw new Error(err.message)\n    })\n\n  const cacheTag = await getCacheTag(\"customers\")\n  revalidateTag(cacheTag)\n\n  return updateRes\n}\n\nexport async function signup(formData: FormData) {\n  const password = formData.get(\"password\") as string\n  const customerForm = {\n    email: formData.get(\"email\") as string,\n    first_name: formData.get(\"first_name\") as string,\n    last_name: formData.get(\"last_name\") as string,\n    phone: formData.get(\"phone\") as string,\n  }\n\n  try {\n    const token = await sdk.auth.register(\"customer\", \"emailpass\", {\n      email: customerForm.email,\n      password: password,\n    })\n\n    await setAuthToken(token as string)\n\n    const headers = {\n      ...(await getAuthHeaders()),\n    }\n\n    const { customer: createdCustomer } = await sdk.store.customer.create(\n      customerForm,\n      {},\n      headers\n    )\n\n    const loginToken = await sdk.auth.login(\"customer\", \"emailpass\", {\n      email: customerForm.email,\n      password,\n    })\n\n    await setAuthToken(loginToken as string)\n\n    const customerCacheTag = await getCacheTag(\"customers\")\n    revalidateTag(customerCacheTag)\n\n    await transferCart()\n\n    return createdCustomer\n  } catch (error: any) {\n    return error.toString()\n  }\n}\n\nexport async function login(formData: FormData) {\n  const email = formData.get(\"email\") as string\n  const password = formData.get(\"password\") as string\n\n  try {\n    await sdk.auth\n      .login(\"customer\", \"emailpass\", { email, password })\n      .then(async (token) => {\n        await setAuthToken(token as string)\n        const customerCacheTag = await getCacheTag(\"customers\")\n        revalidateTag(customerCacheTag)\n      })\n  } catch (error: any) {\n    return error.toString()\n  }\n\n  try {\n    await transferCart()\n  } catch (error: any) {\n    return error.toString()\n  }\n}\n\nexport async function signout() {\n  await sdk.auth.logout()\n\n  await removeAuthToken()\n\n  const customerCacheTag = await getCacheTag(\"customers\")\n  revalidateTag(customerCacheTag)\n\n  await removeCartId()\n\n  const cartCacheTag = await getCacheTag(\"carts\")\n  revalidateTag(cartCacheTag)\n  redirect(`/`)\n}\n\nexport async function transferCart() {\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    return\n  }\n\n  const headers = await getAuthHeaders()\n\n  await sdk.store.cart.transferCart(cartId, {}, headers)\n\n  const cartCacheTag = await getCacheTag(\"carts\")\n  revalidateTag(cartCacheTag)\n}\n\nexport const addCustomerAddress = async (formData: FormData): Promise<any> => {\n  const address = {\n    address_name: formData.get(\"address_name\") as string,\n    first_name: formData.get(\"first_name\") as string,\n    last_name: formData.get(\"last_name\") as string,\n    company: formData.get(\"company\") as string,\n    address_1: formData.get(\"address_1\") as string,\n    city: formData.get(\"city\") as string,\n    postal_code: formData.get(\"postal_code\") as string,\n    country_code: formData.get(\"country_code\") as string,\n    phone: formData.get(\"phone\") as string,\n    province: formData.get(\"province\") as string,\n    is_default_billing: Boolean(formData.get(\"isDefaultBilling\")),\n    is_default_shipping: Boolean(formData.get(\"isDefaultShipping\")),\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return sdk.store.customer\n    .createAddress(address, {}, headers)\n    .then(async ({ customer }) => {\n      const customerCacheTag = await getCacheTag(\"customers\")\n      revalidateTag(customerCacheTag)\n      return { success: true, error: null }\n    })\n    .catch((err) => {\n      return { success: false, error: err.toString() }\n    })\n}\n\nexport const deleteCustomerAddress = async (\n  addressId: string\n): Promise<void> => {\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  await sdk.store.customer\n    .deleteAddress(addressId, headers)\n    .then(async () => {\n      const customerCacheTag = await getCacheTag(\"customers\")\n      revalidateTag(customerCacheTag)\n      return { success: true, error: null }\n    })\n    .catch((err) => {\n      return { success: false, error: err.toString() }\n    })\n}\n\nexport const updateCustomerAddress = async (\n  formData: FormData\n): Promise<any> => {\n  const addressId = formData.get(\"addressId\") as string\n\n  if (!addressId) {\n    return { success: false, error: \"Address ID is required\" }\n  }\n\n  const address = {\n    address_name: formData.get(\"address_name\") as string,\n    first_name: formData.get(\"first_name\") as string,\n    last_name: formData.get(\"last_name\") as string,\n    company: formData.get(\"company\") as string,\n    address_1: formData.get(\"address_1\") as string,\n    address_2: formData.get(\"address_2\") as string,\n    city: formData.get(\"city\") as string,\n    postal_code: formData.get(\"postal_code\") as string,\n    province: formData.get(\"province\") as string,\n    country_code: formData.get(\"country_code\") as string,\n  } as HttpTypes.StoreUpdateCustomerAddress\n\n  const phone = formData.get(\"phone\") as string\n\n  if (phone) {\n    address.phone = phone\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return sdk.store.customer\n    .updateAddress(addressId, address, {}, headers)\n    .then(async () => {\n      const customerCacheTag = await getCacheTag(\"customers\")\n      revalidateTag(customerCacheTag)\n      return { success: true, error: null }\n    })\n    .catch((err) => {\n      return { success: false, error: err.toString() }\n    })\n}\n\nexport const updateCustomerPassword = async (\n  password: string,\n  token: string\n): Promise<any> => {\n  const res = await fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/auth/customer/emailpass/update`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${token}`,\n      },\n      body: JSON.stringify({ password }),\n    }\n  )\n    .then(async () => {\n      await removeAuthToken()\n      const customerCacheTag = await getCacheTag(\"customers\")\n      revalidateTag(customerCacheTag)\n      return { success: true, error: null }\n    })\n    .catch((err: any) => {\n      return { success: false, error: err.toString() }\n    })\n\n  return res\n}\n\nexport const sendResetPasswordEmail = async (email: string) => {\n  const res = await sdk.auth\n    .resetPassword(\"customer\", \"emailpass\", {\n      identifier: email,\n    })\n    .then(() => {\n      return { success: true, error: null }\n    })\n    .catch((err: any) => {\n      return { success: false, error: err.toString() }\n    })\n\n  return res\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;IAgBa;IA4BA;IAkBS;IA6CA;IAuBA;IAeA;IAeT;IAgCA;IAmBA;IA4CA;IA4BA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/get-precentage-diff.ts"],"sourcesContent":["export const getPercentageDiff = (original: number, calculated: number) => {\n  const diff = original - calculated\n  const decrease = (diff / original) * 100\n\n  return decrease.toFixed()\n}\n"],"names":[],"mappings":";;;AAAO,MAAM,oBAAoB,CAAC,UAAkB;IAClD,MAAM,OAAO,WAAW;IACxB,MAAM,WAAW,AAAC,OAAO,WAAY;IAErC,OAAO,SAAS,OAAO;AACzB"}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/isEmpty.ts"],"sourcesContent":["export const isObject = (input: any) => input instanceof Object\nexport const isArray = (input: any) => Array.isArray(input)\nexport const isEmpty = (input: any) => {\n  return (\n    input === null ||\n    input === undefined ||\n    (isObject(input) && Object.keys(input).length === 0) ||\n    (isArray(input) && (input as any[]).length === 0) ||\n    (typeof input === \"string\" && input.trim().length === 0)\n  )\n}\n"],"names":[],"mappings":";;;;;AAAO,MAAM,WAAW,CAAC,QAAe,iBAAiB;AAClD,MAAM,UAAU,CAAC,QAAe,MAAM,OAAO,CAAC;AAC9C,MAAM,UAAU,CAAC;IACtB,OACE,UAAU,QACV,UAAU,aACT,SAAS,UAAU,OAAO,IAAI,CAAC,OAAO,MAAM,KAAK,KACjD,QAAQ,UAAU,AAAC,MAAgB,MAAM,KAAK,KAC9C,OAAO,UAAU,YAAY,MAAM,IAAI,GAAG,MAAM,KAAK;AAE1D"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/money.ts"],"sourcesContent":["import { isEmpty } from \"./isEmpty\"\n\ntype ConvertToLocaleParams = {\n  amount: number\n  currency_code: string\n  minimumFractionDigits?: number\n  maximumFractionDigits?: number\n  locale?: string\n}\n\nexport const convertToLocale = ({\n  amount,\n  currency_code,\n  minimumFractionDigits,\n  maximumFractionDigits,\n  locale = \"en-US\",\n}: ConvertToLocaleParams) => {\n  return currency_code && !isEmpty(currency_code)\n    ? new Intl.NumberFormat(locale, {\n        style: \"currency\",\n        currency: currency_code,\n        minimumFractionDigits,\n        maximumFractionDigits,\n      }).format(amount)\n    : amount.toString()\n}\n"],"names":[],"mappings":";;;AAAA;;AAUO,MAAM,kBAAkB,CAAC,EAC9B,MAAM,EACN,aAAa,EACb,qBAAqB,EACrB,qBAAqB,EACrB,SAAS,OAAO,EACM;IACtB,OAAO,iBAAiB,CAAC,CAAA,GAAA,mIAAA,CAAA,UAAO,AAAD,EAAE,iBAC7B,IAAI,KAAK,YAAY,CAAC,QAAQ;QAC5B,OAAO;QACP,UAAU;QACV;QACA;IACF,GAAG,MAAM,CAAC,UACV,OAAO,QAAQ;AACrB"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/get-product-price.ts"],"sourcesContent":["import { HttpTypes } from \"@medusajs/types\"\nimport { getPercentageDiff } from \"./get-precentage-diff\"\nimport { convertToLocale } from \"./money\"\nimport { BaseHit, Hit } from \"instantsearch.js\"\n\nexport const getPricesForVariant = (variant: any) => {\n  if (\n    !variant?.calculated_price?.calculated_amount_with_tax &&\n    !variant?.calculated_price?.calculated_amount\n  ) {\n    return null\n  }\n\n  if (!variant?.calculated_price?.calculated_amount_with_tax) {\n    return {\n      calculated_price_number: variant.calculated_price.calculated_amount,\n      calculated_price: convertToLocale({\n        amount: variant.calculated_price.calculated_amount,\n        currency_code: variant.calculated_price.currency_code,\n      }),\n      original_price_number: variant.calculated_price.original_amount,\n      original_price: convertToLocale({\n        amount: variant.calculated_price.original_amount,\n        currency_code: variant.calculated_price.currency_code,\n      }),\n      currency_code: variant.calculated_price.currency_code,\n      price_type: variant.calculated_price.calculated_price.price_list_type,\n      percentage_diff: getPercentageDiff(\n        variant.calculated_price.original_amount,\n        variant.calculated_price.calculated_amount\n      ),\n    }\n  }\n\n  return {\n    calculated_price_number:\n      variant.calculated_price.calculated_amount_with_tax,\n    calculated_price: convertToLocale({\n      amount: variant.calculated_price.calculated_amount_with_tax,\n      currency_code: variant.calculated_price.currency_code,\n    }),\n    original_price_number: variant.calculated_price.original_amount_with_tax,\n    original_price: convertToLocale({\n      amount: variant.calculated_price.original_amount_with_tax,\n      currency_code: variant.calculated_price.currency_code,\n    }),\n    currency_code: variant.calculated_price.currency_code,\n    price_type: variant.calculated_price.calculated_price.price_list_type,\n    percentage_diff: getPercentageDiff(\n      variant.calculated_price.original_amount,\n      variant.calculated_price.calculated_amount\n    ),\n  }\n}\n\nexport function getProductPrice({\n  product,\n  variantId,\n}: {\n  product: Hit<HttpTypes.StoreProduct> | Partial<Hit<BaseHit>>\n  variantId?: string\n}) {\n  if (!product || !product.id) {\n    throw new Error(\"No product provided\")\n  }\n\n  const cheapestVariant = () => {\n    if (!product || !product.variants?.length) {\n      return null\n    }\n\n    return product.variants\n      .filter((v: any) => !!v.calculated_price)\n      .sort((a: any, b: any) => {\n        return a.calculated_price.calculated_amount_with_tax &&\n          b.calculated_price.calculated_amount_with_tax\n          ? a.calculated_price.calculated_amount_with_tax -\n              b.calculated_price.calculated_amount_with_tax\n          : a.calculated_amount - b.calculated_amount\n      })[0]\n  }\n\n  const cheapestPrice = () => {\n    if (!product || !product.variants?.length) {\n      return null\n    }\n\n    const variant: any = cheapestVariant()\n\n    return getPricesForVariant(variant)\n  }\n\n  const variantPrice = () => {\n    if (!product || !variantId) {\n      return null\n    }\n\n    const variant: any = product.variants?.find(\n      (v: any) => v.id === variantId || v.sku === variantId\n    )\n\n    if (!variant) {\n      return null\n    }\n\n    return getPricesForVariant(variant)\n  }\n\n  return {\n    product,\n    cheapestPrice: cheapestPrice(),\n    variantPrice: variantPrice(),\n    cheapestVariant: cheapestVariant(),\n  }\n}\n"],"names":[],"mappings":";;;;AACA;AACA;;;AAGO,MAAM,sBAAsB,CAAC;IAClC,IACE,CAAC,SAAS,kBAAkB,8BAC5B,CAAC,SAAS,kBAAkB,mBAC5B;QACA,OAAO;IACT;IAEA,IAAI,CAAC,SAAS,kBAAkB,4BAA4B;QAC1D,OAAO;YACL,yBAAyB,QAAQ,gBAAgB,CAAC,iBAAiB;YACnE,kBAAkB,CAAA,GAAA,iIAAA,CAAA,kBAAe,AAAD,EAAE;gBAChC,QAAQ,QAAQ,gBAAgB,CAAC,iBAAiB;gBAClD,eAAe,QAAQ,gBAAgB,CAAC,aAAa;YACvD;YACA,uBAAuB,QAAQ,gBAAgB,CAAC,eAAe;YAC/D,gBAAgB,CAAA,GAAA,iIAAA,CAAA,kBAAe,AAAD,EAAE;gBAC9B,QAAQ,QAAQ,gBAAgB,CAAC,eAAe;gBAChD,eAAe,QAAQ,gBAAgB,CAAC,aAAa;YACvD;YACA,eAAe,QAAQ,gBAAgB,CAAC,aAAa;YACrD,YAAY,QAAQ,gBAAgB,CAAC,gBAAgB,CAAC,eAAe;YACrE,iBAAiB,CAAA,GAAA,qJAAA,CAAA,oBAAiB,AAAD,EAC/B,QAAQ,gBAAgB,CAAC,eAAe,EACxC,QAAQ,gBAAgB,CAAC,iBAAiB;QAE9C;IACF;IAEA,OAAO;QACL,yBACE,QAAQ,gBAAgB,CAAC,0BAA0B;QACrD,kBAAkB,CAAA,GAAA,iIAAA,CAAA,kBAAe,AAAD,EAAE;YAChC,QAAQ,QAAQ,gBAAgB,CAAC,0BAA0B;YAC3D,eAAe,QAAQ,gBAAgB,CAAC,aAAa;QACvD;QACA,uBAAuB,QAAQ,gBAAgB,CAAC,wBAAwB;QACxE,gBAAgB,CAAA,GAAA,iIAAA,CAAA,kBAAe,AAAD,EAAE;YAC9B,QAAQ,QAAQ,gBAAgB,CAAC,wBAAwB;YACzD,eAAe,QAAQ,gBAAgB,CAAC,aAAa;QACvD;QACA,eAAe,QAAQ,gBAAgB,CAAC,aAAa;QACrD,YAAY,QAAQ,gBAAgB,CAAC,gBAAgB,CAAC,eAAe;QACrE,iBAAiB,CAAA,GAAA,qJAAA,CAAA,oBAAiB,AAAD,EAC/B,QAAQ,gBAAgB,CAAC,eAAe,EACxC,QAAQ,gBAAgB,CAAC,iBAAiB;IAE9C;AACF;AAEO,SAAS,gBAAgB,EAC9B,OAAO,EACP,SAAS,EAIV;IACC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE;QAC3B,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,kBAAkB;QACtB,IAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ,EAAE,QAAQ;YACzC,OAAO;QACT;QAEA,OAAO,QAAQ,QAAQ,CACpB,MAAM,CAAC,CAAC,IAAW,CAAC,CAAC,EAAE,gBAAgB,EACvC,IAAI,CAAC,CAAC,GAAQ;YACb,OAAO,EAAE,gBAAgB,CAAC,0BAA0B,IAClD,EAAE,gBAAgB,CAAC,0BAA0B,GAC3C,EAAE,gBAAgB,CAAC,0BAA0B,GAC3C,EAAE,gBAAgB,CAAC,0BAA0B,GAC/C,EAAE,iBAAiB,GAAG,EAAE,iBAAiB;QAC/C,EAAE,CAAC,EAAE;IACT;IAEA,MAAM,gBAAgB;QACpB,IAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ,EAAE,QAAQ;YACzC,OAAO;QACT;QAEA,MAAM,UAAe;QAErB,OAAO,oBAAoB;IAC7B;IAEA,MAAM,eAAe;QACnB,IAAI,CAAC,WAAW,CAAC,WAAW;YAC1B,OAAO;QACT;QAEA,MAAM,UAAe,QAAQ,QAAQ,EAAE,KACrC,CAAC,IAAW,EAAE,EAAE,KAAK,aAAa,EAAE,GAAG,KAAK;QAG9C,IAAI,CAAC,SAAS;YACZ,OAAO;QACT;QAEA,OAAO,oBAAoB;IAC7B;IAEA,OAAO;QACL;QACA,eAAe;QACf,cAAc;QACd,iBAAiB;IACnB;AACF"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/config.ts"],"sourcesContent":["import Medusa from \"@medusajs/js-sdk\"\n\n// Defaults to standard port for Medusa server\nconst MEDUSA_BACKEND_URL =\n  process.env.MEDUSA_BACKEND_URL || \"http://localhost:9000\"\n\nexport const sdk = new Medusa({\n  baseUrl: MEDUSA_BACKEND_URL,\n  debug: process.env.NODE_ENV === \"development\",\n  publishableKey: process.env.NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY,\n})\n"],"names":[],"mappings":";;;AAAA;AAIE;AAJF;;AAEA,8CAA8C;AAC9C,MAAM,qBACJ,gKAAA,CAAA,UAAO,CAAC,GAAG,CAAC,kBAAkB,IAAI;AAE7B,MAAM,MAAM,IAAI,kLAAA,CAAA,UAAM,CAAC;IAC5B,SAAS;IACT,OAAO,oDAAyB;IAChC,cAAc;AAChB"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/categories.ts"],"sourcesContent":["import { sdk } from \"@/lib/config\"\nimport { HttpTypes } from \"@medusajs/types\"\n\ninterface CategoriesProps {\n  query?: Record<string, any>\n  headingCategories?: string[]\n}\n\nexport const listCategories = async ({\n  query,\n  headingCategories = [],\n}: Partial<CategoriesProps> = {}) => {\n  const limit = query?.limit || 100\n\n  const categories = await sdk.client\n    .fetch<{\n      product_categories: HttpTypes.StoreProductCategory[]\n    }>(\"/store/product-categories\", {\n      query: {\n        fields: \"handle, name, rank, parent_category_id\",\n        limit,\n        ...query,\n      },\n      cache: \"force-cache\",\n      next: { revalidate: 3600 },\n    })\n    .then(({ product_categories }) => product_categories)\n\n  const parentCategories = categories.filter(({ name }) =>\n    headingCategories.includes(name.toLowerCase())\n  )\n\n  const childrenCategories = categories.filter(\n    ({ name }) => !headingCategories.includes(name.toLowerCase())\n  )\n\n  return {\n    categories: childrenCategories.filter(\n      ({ parent_category_id }) => !parent_category_id\n    ),\n    parentCategories: parentCategories,\n  }\n}\n\nexport const getCategoryByHandle = async (categoryHandle: string[]) => {\n  const handle = `${categoryHandle.join(\"/\")}`\n\n  return sdk.client\n    .fetch<HttpTypes.StoreProductCategoryListResponse>(\n      `/store/product-categories`,\n      {\n        query: {\n          fields: \"*category_children\",\n          handle,\n        },\n        cache: \"force-cache\",\n        next: { revalidate: 300 },\n      }\n    )\n    .then(({ product_categories }) => product_categories[0])\n}\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,iBAAiB,OAAO,EACnC,KAAK,EACL,oBAAoB,EAAE,EACG,GAAG,CAAC,CAAC;IAC9B,MAAM,QAAQ,OAAO,SAAS;IAE9B,MAAM,aAAa,MAAM,uHAAA,CAAA,MAAG,CAAC,MAAM,CAChC,KAAK,CAEH,6BAA6B;QAC9B,OAAO;YACL,QAAQ;YACR;YACA,GAAG,KAAK;QACV;QACA,OAAO;QACP,MAAM;YAAE,YAAY;QAAK;IAC3B,GACC,IAAI,CAAC,CAAC,EAAE,kBAAkB,EAAE,GAAK;IAEpC,MAAM,mBAAmB,WAAW,MAAM,CAAC,CAAC,EAAE,IAAI,EAAE,GAClD,kBAAkB,QAAQ,CAAC,KAAK,WAAW;IAG7C,MAAM,qBAAqB,WAAW,MAAM,CAC1C,CAAC,EAAE,IAAI,EAAE,GAAK,CAAC,kBAAkB,QAAQ,CAAC,KAAK,WAAW;IAG5D,OAAO;QACL,YAAY,mBAAmB,MAAM,CACnC,CAAC,EAAE,kBAAkB,EAAE,GAAK,CAAC;QAE/B,kBAAkB;IACpB;AACF;AAEO,MAAM,sBAAsB,OAAO;IACxC,MAAM,SAAS,GAAG,eAAe,IAAI,CAAC,MAAM;IAE5C,OAAO,uHAAA,CAAA,MAAG,CAAC,MAAM,CACd,KAAK,CACJ,CAAC,yBAAyB,CAAC,EAC3B;QACE,OAAO;YACL,QAAQ;YACR;QACF;QACA,OAAO;QACP,MAAM;YAAE,YAAY;QAAI;IAC1B,GAED,IAAI,CAAC,CAAC,EAAE,kBAAkB,EAAE,GAAK,kBAAkB,CAAC,EAAE;AAC3D"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/cart.ts"],"sourcesContent":["\"use server\"\n\nimport { sdk } from \"../config\"\nimport medusaError from \"@/lib/helpers/medusa-error\"\nimport { HttpTypes } from \"@medusajs/types\"\nimport { revalidatePath, revalidateTag } from \"next/cache\"\nimport { redirect } from \"next/navigation\"\nimport {\n  getAuthHeaders,\n  getCacheOptions,\n  getCacheTag,\n  getCartId,\n  removeCartId,\n  setCartId,\n} from \"./cookies\"\nimport { getRegion } from \"./regions\"\n\n/**\n * Retrieves a cart by its ID. If no ID is provided, it will use the cart ID from the cookies.\n * @param cartId - optional - The ID of the cart to retrieve.\n * @returns The cart object if found, or null if not found.\n */\nexport async function retrieveCart(cartId?: string) {\n  const id = cartId || (await getCartId())\n\n  if (!id) {\n    return null\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return await sdk.client\n    .fetch<HttpTypes.StoreCartResponse>(`/store/carts/${id}`, {\n      method: \"GET\",\n      query: {\n        fields:\n          \"*items,*region, *items.product, *items.variant, *items.variant.options, items.variant.options.option.title,\" +\n          \"*items.thumbnail, *items.metadata, +items.total, *promotions, +shipping_methods.name, *items.product.seller\" +\n          \"\",\n      },\n      headers,\n      cache: \"no-cache\",\n    })\n    .then(({ cart }) => cart)\n    .catch(() => null)\n}\n\nexport async function getOrSetCart(countryCode: string) {\n  const region = await getRegion(countryCode)\n\n  if (!region) {\n    throw new Error(`Region not found for country code: ${countryCode}`)\n  }\n\n  let cart = await retrieveCart()\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  if (!cart) {\n    const cartResp = await sdk.store.cart.create(\n      { region_id: region.id },\n      {},\n      headers\n    )\n    cart = cartResp.cart\n\n    await setCartId(cart.id)\n\n    const cartCacheTag = await getCacheTag(\"carts\")\n    revalidateTag(cartCacheTag)\n  }\n\n  if (cart && cart?.region_id !== region.id) {\n    await sdk.store.cart.update(cart.id, { region_id: region.id }, {}, headers)\n    const cartCacheTag = await getCacheTag(\"carts\")\n    revalidateTag(cartCacheTag)\n  }\n\n  return cart\n}\n\nexport async function updateCart(data: HttpTypes.StoreUpdateCart) {\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"No existing cart found, please create one before updating\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return await sdk.store.cart\n    .update(cartId, data, {}, headers)\n    .then(async ({ cart }) => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      await revalidateTag(cartCacheTag)\n      return cart\n    })\n    .catch(medusaError)\n}\n\nexport async function addToCart({\n  variantId,\n  quantity,\n  countryCode,\n}: {\n  variantId: string\n  quantity: number\n  countryCode: string\n}) {\n  if (!variantId) {\n    throw new Error(\"Missing variant ID when adding to cart\")\n  }\n\n  const cart = await getOrSetCart(countryCode)\n\n  if (!cart) {\n    throw new Error(\"Error retrieving or creating cart\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  const currentItem = cart.items?.find((item) => item.variant_id === variantId)\n\n  if (currentItem) {\n    await sdk.store.cart\n      .updateLineItem(\n        cart.id,\n        currentItem.id,\n        { quantity: currentItem.quantity + quantity },\n        {},\n        headers\n      )\n      .then(async () => {\n        const cartCacheTag = await getCacheTag(\"carts\")\n        revalidateTag(cartCacheTag)\n      })\n      .catch(medusaError)\n  } else {\n    await sdk.store.cart\n      .createLineItem(\n        cart.id,\n        {\n          variant_id: variantId,\n          quantity,\n        },\n        {},\n        headers\n      )\n      .then(async () => {\n        const cartCacheTag = await getCacheTag(\"carts\")\n        revalidateTag(cartCacheTag)\n      })\n      .catch(medusaError)\n  }\n}\n\nexport async function updateLineItem({\n  lineId,\n  quantity,\n}: {\n  lineId: string\n  quantity: number\n}) {\n  if (!lineId) {\n    throw new Error(\"Missing lineItem ID when updating line item\")\n  }\n\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"Missing cart ID when updating line item\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  await sdk.store.cart\n    .updateLineItem(cartId, lineId, { quantity }, {}, headers)\n    .then(async () => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      await revalidateTag(cartCacheTag)\n    })\n    .catch(medusaError)\n}\n\nexport async function deleteLineItem(lineId: string) {\n  if (!lineId) {\n    throw new Error(\"Missing lineItem ID when deleting line item\")\n  }\n\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"Missing cart ID when deleting line item\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  await sdk.store.cart\n    .deleteLineItem(cartId, lineId, headers)\n    .then(async () => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      await revalidateTag(cartCacheTag)\n    })\n    .catch(medusaError)\n}\n\nexport async function setShippingMethod({\n  cartId,\n  shippingMethodId,\n}: {\n  cartId: string\n  shippingMethodId: string\n}) {\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return sdk.store.cart\n    .addShippingMethod(cartId, { option_id: shippingMethodId }, {}, headers)\n    .then(async () => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n    })\n    .catch(medusaError)\n}\n\nexport async function initiatePaymentSession(\n  cart: HttpTypes.StoreCart,\n  data: {\n    provider_id: string\n    context?: Record<string, unknown>\n  }\n) {\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return sdk.store.payment\n    .initiatePaymentSession(cart, data, {}, headers)\n    .then(async (resp) => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n      return resp\n    })\n    .catch(medusaError)\n}\n\nexport async function applyPromotions(codes: string[]) {\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"No existing cart found\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  return sdk.store.cart\n    .update(cartId, { promo_codes: codes }, {}, headers)\n    .then(async ({ cart }) => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n      // @ts-ignore\n      const applied = cart.promotions?.some((promotion: any) =>\n        codes.includes(promotion.code)\n      )\n      return applied\n    })\n    .catch(medusaError)\n}\n\nexport async function removeShippingMethod(shippingMethodId: string) {\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"No existing cart found\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  return fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/store/carts/${cartId}/shipping-methods`,\n    {\n      method: \"DELETE\",\n      body: JSON.stringify({ shipping_method_ids: [shippingMethodId] }),\n      headers,\n    }\n  )\n    .then(async () => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n    })\n    .catch(medusaError)\n}\n\nexport async function deletePromotionCode(promoId: string) {\n  const cartId = await getCartId()\n\n  if (!cartId) {\n    throw new Error(\"No existing cart found\")\n  }\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  return fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/store/carts/${cartId}/promotions`,\n    {\n      method: \"DELETE\",\n      body: JSON.stringify({ promo_codes: [promoId] }),\n      headers,\n    }\n  )\n    .then(async () => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n    })\n    .catch(medusaError)\n}\n\n// TODO: Pass a POJO instead of a form entity here\nexport async function setAddresses(currentState: unknown, formData: FormData) {\n  try {\n    if (!formData) {\n      throw new Error(\"No form data found when setting addresses\")\n    }\n    const cartId = getCartId()\n    if (!cartId) {\n      throw new Error(\"No existing cart found when setting addresses\")\n    }\n\n    const data = {\n      shipping_address: {\n        first_name: formData.get(\"shipping_address.first_name\"),\n        last_name: formData.get(\"shipping_address.last_name\"),\n        address_1: formData.get(\"shipping_address.address_1\"),\n        address_2: \"\",\n        company: formData.get(\"shipping_address.company\"),\n        postal_code: formData.get(\"shipping_address.postal_code\"),\n        city: formData.get(\"shipping_address.city\"),\n        country_code: formData.get(\"shipping_address.country_code\"),\n        province: formData.get(\"shipping_address.province\"),\n        phone: formData.get(\"shipping_address.phone\"),\n      },\n      email: formData.get(\"email\"),\n    } as any\n\n    // const sameAsBilling = formData.get(\"same_as_billing\")\n    // if (sameAsBilling === \"on\") data.billing_address = data.shipping_address\n    data.billing_address = data.shipping_address\n\n    // if (sameAsBilling !== \"on\")\n    //   data.billing_address = {\n    //     first_name: formData.get(\"billing_address.first_name\"),\n    //     last_name: formData.get(\"billing_address.last_name\"),\n    //     address_1: formData.get(\"billing_address.address_1\"),\n    //     address_2: \"\",\n    //     company: formData.get(\"billing_address.company\"),\n    //     postal_code: formData.get(\"billing_address.postal_code\"),\n    //     city: formData.get(\"billing_address.city\"),\n    //     country_code: formData.get(\"billing_address.country_code\"),\n    //     province: formData.get(\"billing_address.province\"),\n    //     phone: formData.get(\"billing_address.phone\"),\n    //   }\n\n    await updateCart(data)\n    await revalidatePath(\"/cart\")\n  } catch (e: any) {\n    return e.message\n  }\n}\n\n/**\n * Places an order for a cart. If no cart ID is provided, it will use the cart ID from the cookies.\n * @param cartId - optional - The ID of the cart to place an order for.\n * @returns The cart object if the order was successful, or null if not.\n */\nexport async function placeOrder(cartId?: string) {\n  const id = cartId || (await getCartId())\n\n  if (!id) {\n    throw new Error(\"No existing cart found when placing an order\")\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  const cartRes: any = await sdk.store.cart\n    .complete(id, {}, headers)\n    .then(async (cartRes) => {\n      const cartCacheTag = await getCacheTag(\"carts\")\n      revalidateTag(cartCacheTag)\n      return cartRes\n    })\n    .catch(medusaError)\n\n  if (cartRes?.order_set) {\n    revalidatePath(\"/user/reviews\")\n    revalidatePath(\"/user/orders\")\n    removeCartId()\n    redirect(`/order/${cartRes?.order_set.orders[0].id}/confirmed`)\n  }\n\n  return cartRes.order_set.cart\n}\n\n/**\n * Updates the countrycode param and revalidates the regions cache\n * @param regionId\n * @param countryCode\n */\nexport async function updateRegion(countryCode: string, currentPath: string) {\n  const cartId = await getCartId()\n  const region = await getRegion(countryCode)\n\n  if (!region) {\n    throw new Error(`Region not found for country code: ${countryCode}`)\n  }\n\n  if (cartId) {\n    await updateCart({ region_id: region.id })\n    const cartCacheTag = await getCacheTag(\"carts\")\n    revalidateTag(cartCacheTag)\n  }\n\n  const regionCacheTag = await getCacheTag(\"regions\")\n  revalidateTag(regionCacheTag)\n\n  const productsCacheTag = await getCacheTag(\"products\")\n  revalidateTag(productsCacheTag)\n\n  redirect(`/${countryCode}${currentPath}`)\n}\n\nexport async function listCartOptions() {\n  const cartId = await getCartId()\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n  const next = {\n    ...(await getCacheOptions(\"shippingOptions\")),\n  }\n\n  return await sdk.client.fetch<{\n    shipping_options: HttpTypes.StoreCartShippingOption[]\n  }>(\"/store/shipping-options\", {\n    query: { cart_id: cartId },\n    next,\n    headers,\n    cache: \"force-cache\",\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;IAsBsB;IA2BA;IAoCA;IAqBA;IA0DA;IA8BA;IAwBA;IAoBA;IAqBA;IAyBA;IA6BA;IA6BA;IAwDA;IAmCA;IAuBA"}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/wishlist.ts"],"sourcesContent":["\"use server\"\nimport { Wishlist } from \"@/types/wishlist\"\nimport { sdk } from \"../config\"\nimport { getAuthHeaders } from \"./cookies\"\nimport { revalidatePath } from \"next/cache\"\n\nexport const getUserWishlists = async () => {\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  return sdk.client\n    .fetch<{ wishlists: Wishlist[]; count: number }>(`/store/wishlist`, {\n      cache: \"no-cache\",\n      headers,\n      method: \"GET\",\n    })\n    .then((res) => {\n      return res\n    })\n}\n\nexport const addWishlistItem = async ({\n  reference_id,\n  reference,\n}: {\n  reference_id: string\n  reference: \"product\"\n}) => {\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  const response = await fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/store/wishlist`,\n    {\n      headers,\n      method: \"POST\",\n      body: JSON.stringify({\n        reference,\n        reference_id,\n      }),\n    }\n  ).then(() => {\n    revalidatePath(\"/wishlist\")\n  })\n}\n\nexport const removeWishlistItem = async ({\n  wishlist_id,\n  product_id,\n}: {\n  wishlist_id: string\n  product_id: string\n}) => {\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  const response = await fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/store/wishlist/${wishlist_id}/product/${product_id}`,\n    {\n      headers,\n      method: \"DELETE\",\n    }\n  ).then(() => {\n    revalidatePath(\"/wishlist\")\n  })\n}\n"],"names":[],"mappings":";;;;;;;IAMa;IAmBA;IA6BA"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 333, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/regions.ts"],"sourcesContent":["\"use server\"\n\nimport { sdk } from \"../config\"\nimport medusaError from \"@/lib/helpers/medusa-error\"\nimport { HttpTypes } from \"@medusajs/types\"\nimport { getCacheOptions } from \"./cookies\"\n\nexport const listRegions = async () => {\n  const next = {\n    ...(await getCacheOptions(\"regions\")),\n    revalidate: 3600,\n  }\n\n  return sdk.client\n    .fetch<{ regions: HttpTypes.StoreRegion[] }>(`/store/regions`, {\n      method: \"GET\",\n      next,\n      cache: \"force-cache\",\n    })\n    .then(({ regions }) => regions)\n    .catch(medusaError)\n}\n\nexport const retrieveRegion = async (id: string) => {\n  const next = {\n    ...(await getCacheOptions([\"regions\", id].join(\"-\"))),\n    revalidate: 3600,\n  }\n\n  return sdk.client\n    .fetch<{ region: HttpTypes.StoreRegion }>(`/store/regions/${id}`, {\n      method: \"GET\",\n      next,\n      cache: \"force-cache\",\n    })\n    .then(({ region }) => region)\n    .catch(medusaError)\n}\n\nconst regionMap = new Map<string, HttpTypes.StoreRegion>()\n\nexport const getRegion = async (countryCode: string) => {\n  try {\n    if (regionMap.has(countryCode)) {\n      return regionMap.get(countryCode)\n    }\n\n    const regions = await listRegions()\n\n    if (!regions) {\n      return null\n    }\n\n    regions.forEach((region) => {\n      region.countries?.forEach((c) => {\n        regionMap.set(c?.iso_2 ?? \"\", region)\n      })\n    })\n\n    const region = countryCode\n      ? regionMap.get(countryCode)\n      : regionMap.get(\"us\")\n\n    return region\n  } catch (e: any) {\n    return null\n  }\n}\n"],"names":[],"mappings":";;;;;;;IAOa;IAgBA;IAkBA"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/products.ts"],"sourcesContent":["\"use server\"\n\nimport { sdk } from \"../config\"\nimport { sortProducts } from \"@/lib/helpers/sort-products\"\nimport { HttpTypes } from \"@medusajs/types\"\nimport { SortOptions } from \"@/types/product\"\nimport { getAuthHeaders } from \"./cookies\"\nimport { getRegion, retrieveRegion } from \"./regions\"\nimport { SellerProps } from \"@/types/seller\"\n\nexport const listProducts = async ({\n  pageParam = 1,\n  queryParams,\n  countryCode,\n  regionId,\n  category_id,\n  collection_id,\n}: {\n  pageParam?: number\n  queryParams?: HttpTypes.FindParams &\n    HttpTypes.StoreProductParams & {\n      handle?: string\n    }\n  category_id?: string\n  collection_id?: string\n  countryCode?: string\n  regionId?: string\n}): Promise<{\n  response: {\n    products: (HttpTypes.StoreProduct & { seller?: SellerProps })[]\n    count: number\n  }\n  nextPage: number | null\n  queryParams?: HttpTypes.FindParams & HttpTypes.StoreProductParams\n}> => {\n  if (!countryCode && !regionId) {\n    throw new Error(\"Country code or region ID is required\")\n  }\n\n  const limit = queryParams?.limit || 12\n  const _pageParam = Math.max(pageParam, 1)\n  const offset = (_pageParam - 1) * limit\n\n  let region: HttpTypes.StoreRegion | undefined | null\n\n  if (countryCode) {\n    region = await getRegion(countryCode)\n  } else {\n    region = await retrieveRegion(regionId!)\n  }\n\n  if (!region) {\n    return {\n      response: { products: [], count: 0 },\n      nextPage: null,\n    }\n  }\n\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  const useCached = limit <= 8 && !category_id && !collection_id\n\n  return sdk.client\n    .fetch<{\n      products: (HttpTypes.StoreProduct & { seller?: SellerProps })[]\n      count: number\n    }>(`/store/products`, {\n      method: \"GET\",\n      query: {\n        country_code: countryCode,\n        category_id,\n        collection_id,\n        limit,\n        offset,\n        region_id: region?.id,\n        fields:\n          \"*variants.calculated_price,+variants.inventory_quantity,*seller,*variants,*seller.products,\" +\n          \"*seller.reviews,*seller.reviews.customer,*seller.reviews.seller,*seller.products.variants,*attribute_values,*attribute_values.attribute\",\n        ...queryParams,\n      },\n      headers,\n      next: useCached ? { revalidate: 60 } : undefined,\n      cache: useCached ? \"force-cache\" : \"no-cache\",\n    })\n    .then(({ products: productsRaw, count }) => {\n      const products = productsRaw.filter(\n        (product) => product.seller?.store_status !== \"SUSPENDED\"\n      )\n\n      const nextPage = count > offset + limit ? pageParam + 1 : null\n\n      const response = products.filter((prod) => {\n        // @ts-ignore Property 'seller' exists but TypeScript doesn't recognize it\n        const reviews = prod.seller?.reviews.filter((item) => !!item) ?? []\n        return (\n          // @ts-ignore Property 'seller' exists but TypeScript doesn't recognize it\n          prod?.seller && {\n            ...prod,\n            seller: {\n              // @ts-ignore Property 'seller' exists but TypeScript doesn't recognize it\n              ...prod.seller,\n              reviews,\n            },\n          }\n        )\n      })\n\n      return {\n        response: {\n          products: response,\n          count,\n        },\n        nextPage: nextPage,\n        queryParams,\n      }\n    })\n}\n\n/**\n * This will fetch 100 products to the Next.js cache and sort them based on the sortBy parameter.\n * It will then return the paginated products based on the page and limit parameters.\n */\nexport const listProductsWithSort = async ({\n  page = 1,\n  queryParams,\n  sortBy = \"created_at\",\n  countryCode,\n  category_id,\n  seller_id,\n  collection_id,\n}: {\n  page?: number\n  queryParams?: HttpTypes.FindParams & HttpTypes.StoreProductParams\n  sortBy?: SortOptions\n  countryCode: string\n  category_id?: string\n  seller_id?: string\n  collection_id?: string\n}): Promise<{\n  response: {\n    products: HttpTypes.StoreProduct[]\n    count: number\n  }\n  nextPage: number | null\n  queryParams?: HttpTypes.FindParams & HttpTypes.StoreProductParams\n}> => {\n  const limit = queryParams?.limit || 12\n\n  const {\n    response: { products, count },\n  } = await listProducts({\n    pageParam: 0,\n    queryParams: {\n      ...queryParams,\n      limit: 100,\n    },\n    category_id,\n    collection_id,\n    countryCode,\n  })\n\n  const filteredProducts = seller_id\n    ? products.filter((product) => product.seller?.id === seller_id)\n    : products\n\n  const pricedProducts = filteredProducts.filter((prod) =>\n    prod.variants?.some((variant) => variant.calculated_price !== null)\n  )\n\n  const sortedProducts = sortProducts(pricedProducts, sortBy)\n\n  const pageParam = (page - 1) * limit\n\n  const nextPage = count > pageParam + limit ? pageParam + limit : null\n\n  const paginatedProducts = sortedProducts.slice(pageParam, pageParam + limit)\n\n  return {\n    response: {\n      products: paginatedProducts,\n      count,\n    },\n    nextPage,\n    queryParams,\n  }\n}\n"],"names":[],"mappings":";;;;;;IAUa;IAkHA"}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/seller.ts"],"sourcesContent":["import { SellerProps } from \"@/types/seller\"\nimport { sdk } from \"../config\"\n\nexport const getSellerByHandle = async (handle: string) => {\n  return sdk.client\n    .fetch<{ seller: SellerProps }>(`/store/seller/${handle}`, {\n      query: {\n        fields:\n          \"+created_at,+email,+reviews.seller.name,+reviews.rating,+reviews.customer_note,+reviews.seller_note,+reviews.created_at,+reviews.updated_at,+reviews.customer.first_name,+reviews.customer.last_name\",\n      },\n      cache: \"no-cache\",\n    })\n    .then(({ seller }) => {\n      const response = {\n        ...seller,\n        reviews:\n          seller.reviews\n            ?.filter((item) => item !== null)\n            .sort((a, b) => b.created_at.localeCompare(a.created_at)) ?? [],\n      }\n\n      return response as SellerProps\n    })\n    .catch(() => [])\n}\n"],"names":[],"mappings":";;;AACA;;AAEO,MAAM,oBAAoB,OAAO;IACtC,OAAO,uHAAA,CAAA,MAAG,CAAC,MAAM,CACd,KAAK,CAA0B,CAAC,cAAc,EAAE,QAAQ,EAAE;QACzD,OAAO;YACL,QACE;QACJ;QACA,OAAO;IACT,GACC,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE;QACf,MAAM,WAAW;YACf,GAAG,MAAM;YACT,SACE,OAAO,OAAO,EACV,OAAO,CAAC,OAAS,SAAS,MAC3B,KAAK,CAAC,GAAG,IAAM,EAAE,UAAU,CAAC,aAAa,CAAC,EAAE,UAAU,MAAM,EAAE;QACrE;QAEA,OAAO;IACT,GACC,KAAK,CAAC,IAAM,EAAE;AACnB"}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/toast.ts"],"sourcesContent":["import { toast as sonnerToast } from \"sonner\"\n\nexport const toast = {\n  info: ({ description, title }: { description?: string; title: string }) => {\n    sonnerToast.info(title, {\n      className: \"bg-blue-100 text-blue-900\",\n      description,\n    })\n  },\n  success: ({\n    description,\n    title,\n  }: {\n    description?: string\n    title: string\n  }) => {\n    sonnerToast.success(title, {\n      className: \"bg-green-100 text-green-900\",\n      description,\n    })\n  },\n  error: ({ description, title }: { description?: string; title: string }) => {\n    sonnerToast.error(title, {\n      className: \"bg-red-100 text-red-900\",\n      description,\n    })\n  },\n}\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,QAAQ;IACnB,MAAM,CAAC,EAAE,WAAW,EAAE,KAAK,EAA2C;QACpE,2IAAA,CAAA,QAAW,CAAC,IAAI,CAAC,OAAO;YACtB,WAAW;YACX;QACF;IACF;IACA,SAAS,CAAC,EACR,WAAW,EACX,KAAK,EAIN;QACC,2IAAA,CAAA,QAAW,CAAC,OAAO,CAAC,OAAO;YACzB,WAAW;YACX;QACF;IACF;IACA,OAAO,CAAC,EAAE,WAAW,EAAE,KAAK,EAA2C;QACrE,2IAAA,CAAA,QAAW,CAAC,KAAK,CAAC,OAAO;YACvB,WAAW;YACX;QACF;IACF;AACF"}},
    {"offset": {"line": 419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/data/reviews.ts"],"sourcesContent":["\"use server\"\nimport { revalidatePath } from \"next/cache\"\nimport { sdk } from \"../config\"\nimport { getAuthHeaders } from \"./cookies\"\nimport { HttpTypes } from \"@medusajs/types\"\n\nexport type Review = {\n  id: string\n  seller: {\n    id: string\n    name: string\n    photo: string\n  }\n  reference: string\n  customer_note: string\n  rating: number\n  updated_at: string\n}\n\nexport type Order = HttpTypes.StoreOrder & {\n  seller: { id: string; name: string; reviews?: any[] }\n  reviews: any[]\n}\n\nconst getReviews = async () => {\n  const headers = {\n    ...(await getAuthHeaders()),\n  }\n\n  const reviews = await sdk.client.fetch(\"/store/reviews\", {\n    headers,\n    query: { fields: \"*seller,+customer.id,+order_id\" },\n    method: \"GET\",\n  })\n\n  return reviews as { reviews: Review[] }\n}\n\nconst createReview = async (review: any) => {\n  const headers = {\n    ...(await getAuthHeaders()),\n    \"Content-Type\": \"application/json\",\n    \"x-publishable-api-key\": process.env\n      .NEXT_PUBLIC_MEDUSA_PUBLISHABLE_KEY as string,\n  }\n\n  const response = await fetch(\n    `${process.env.MEDUSA_BACKEND_URL}/store/reviews`,\n    {\n      headers,\n      method: \"POST\",\n      body: JSON.stringify(review),\n    }\n  ).then((res) => {\n    revalidatePath(\"/user/reviews\")\n    revalidatePath(\"/user/reviews/written\")\n    return res\n  })\n\n  return response.json()\n}\n\nexport { getReviews, createReview }\n"],"names":[],"mappings":";;;;;;IA8DS;IAAY"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 439, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/client.tsx"],"sourcesContent":["import { liteClient as algoliasearch } from \"algoliasearch/lite\"\n\nconst algoliaId = process.env.NEXT_PUBLIC_ALGOLIA_ID || \"supersecret\"\nconst algoliaSearchKey =\n  process.env.NEXT_PUBLIC_ALGOLIA_SEARCH_KEY || \"supersecret\"\n\nexport const client = algoliasearch(algoliaId, algoliaSearchKey)\n"],"names":[],"mappings":";;;AAAA;AAEkB;;AAAlB,MAAM,YAAY,wCAAsC;AACxD,MAAM,mBACJ,wCAA8C;AAEzC,MAAM,SAAS,CAAA,GAAA,qKAAA,CAAA,aAAa,AAAD,EAAE,WAAW"}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/get-faced-filters.ts"],"sourcesContent":["import { FacetFilters } from \"algoliasearch/lite\"\nimport { ReadonlyURLSearchParams } from \"next/navigation\"\n\nconst getOption = (label: string) => {\n  switch (label) {\n    case \"size\":\n      return \"variants.size\"\n    case \"color\":\n      return \"variants.color\"\n    case \"condition\":\n      return \"variants.condition\"\n    case \"rating\":\n      return \"average_rating\"\n    default:\n      return \"\"\n  }\n}\n\nexport const getFacedFilters = (filters: ReadonlyURLSearchParams): string => {\n  let facet = \"\"\n\n  let minPrice = null\n  let maxPrice = null\n\n  let query = \"\"\n  let rating = \"\"\n\n  for (const [key, value] of filters.entries()) {\n    if (\n      key !== \"min_price\" &&\n      key !== \"max_price\" &&\n      key !== \"sale\" &&\n      key !== \"query\" &&\n      key !== \"page\" &&\n      key !== \"products[page]\" &&\n      key !== \"sortBy\" &&\n      key !== \"rating\"\n    ) {\n      let values = \"\"\n      const splittedSize = value.split(\",\")\n      if (splittedSize.length > 1) {\n        splittedSize.map(\n          (value, index) =>\n            (values += `${getOption(key)}:\"${value}\" ${\n              index + 1 < splittedSize.length ? \"OR \" : \"\"\n            }`)\n        )\n      } else {\n        values += `${getOption(key)}:\"${splittedSize[0]}\"`\n      }\n      facet += ` AND ${values}`\n    } else {\n      if (key === \"min_price\") minPrice = value\n      if (key === \"max_price\") maxPrice = value\n\n      if (key === \"query\") query = ` AND products.title:\"${value}\"`\n\n      if (key === \"rating\") {\n        let values = \"\"\n        const splited = value.split(\",\")\n        if (splited.length > 1) {\n          splited.map(\n            (value, index) =>\n              (values += `${getOption(key)} >= ${value} ${\n                index + 1 < splited.length ? \"OR \" : \"\"\n              }`)\n          )\n        } else {\n          values += `${getOption(key)} >=${splited[0]}`\n        }\n        rating += ` AND ${values}`\n      }\n    }\n  }\n\n  const priceFilter =\n    minPrice && maxPrice\n      ? ` AND variants.prices.amount:${minPrice} TO ${maxPrice}`\n      : minPrice\n      ? ` AND variants.prices.amount >= ${minPrice}`\n      : maxPrice\n      ? ` AND variants.prices.amount <= ${maxPrice}`\n      : \"\"\n\n  return facet + priceFilter + rating\n}\n"],"names":[],"mappings":";;;AAGA,MAAM,YAAY,CAAC;IACjB,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,OAAO;IACX;AACF;AAEO,MAAM,kBAAkB,CAAC;IAC9B,IAAI,QAAQ;IAEZ,IAAI,WAAW;IACf,IAAI,WAAW;IAEf,IAAI,QAAQ;IACZ,IAAI,SAAS;IAEb,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAQ,OAAO,GAAI;QAC5C,IACE,QAAQ,eACR,QAAQ,eACR,QAAQ,UACR,QAAQ,WACR,QAAQ,UACR,QAAQ,oBACR,QAAQ,YACR,QAAQ,UACR;YACA,IAAI,SAAS;YACb,MAAM,eAAe,MAAM,KAAK,CAAC;YACjC,IAAI,aAAa,MAAM,GAAG,GAAG;gBAC3B,aAAa,GAAG,CACd,CAAC,OAAO,QACL,UAAU,GAAG,UAAU,KAAK,EAAE,EAAE,MAAM,EAAE,EACvC,QAAQ,IAAI,aAAa,MAAM,GAAG,QAAQ,IAC1C;YAER,OAAO;gBACL,UAAU,GAAG,UAAU,KAAK,EAAE,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC;YACpD;YACA,SAAS,CAAC,KAAK,EAAE,QAAQ;QAC3B,OAAO;YACL,IAAI,QAAQ,aAAa,WAAW;YACpC,IAAI,QAAQ,aAAa,WAAW;YAEpC,IAAI,QAAQ,SAAS,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC;YAE7D,IAAI,QAAQ,UAAU;gBACpB,IAAI,SAAS;gBACb,MAAM,UAAU,MAAM,KAAK,CAAC;gBAC5B,IAAI,QAAQ,MAAM,GAAG,GAAG;oBACtB,QAAQ,GAAG,CACT,CAAC,OAAO,QACL,UAAU,GAAG,UAAU,KAAK,IAAI,EAAE,MAAM,CAAC,EACxC,QAAQ,IAAI,QAAQ,MAAM,GAAG,QAAQ,IACrC;gBAER,OAAO;oBACL,UAAU,GAAG,UAAU,KAAK,GAAG,EAAE,OAAO,CAAC,EAAE,EAAE;gBAC/C;gBACA,UAAU,CAAC,KAAK,EAAE,QAAQ;YAC5B;QACF;IACF;IAEA,MAAM,cACJ,YAAY,WACR,CAAC,4BAA4B,EAAE,SAAS,IAAI,EAAE,UAAU,GACxD,WACA,CAAC,+BAA+B,EAAE,UAAU,GAC5C,WACA,CAAC,+BAA+B,EAAE,UAAU,GAC5C;IAEN,OAAO,QAAQ,cAAc;AAC/B"}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/lib/helpers/parcel-statuses.ts"],"sourcesContent":["export const steps = [\"Received\", \"Preparing\", \"Shipped\", \"Delivered\"]\n\nexport const parcelStatuses = (\n  order: \"not_fulfilled\" | \"fulfilled\" | \"delivered\" | \"shipped\"\n) => {\n  switch (order) {\n    case \"not_fulfilled\":\n      return 0\n    case \"fulfilled\":\n      return 1\n    case \"delivered\":\n      return 3\n    case \"shipped\":\n      return 2\n    default:\n      return 0\n  }\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM,QAAQ;IAAC;IAAY;IAAa;IAAW;CAAY;AAE/D,MAAM,iBAAiB,CAC5B;IAEA,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,OAAO;IACX;AACF"}},
    {"offset": {"line": 545, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/data/categories.ts"],"sourcesContent":["export const primeCategories = {\n  menswear: 'Menswear',\n  womenswear: 'Womenswear',\n};\n\nexport const categories = {\n  clothing: 'Clothing',\n  footwear: 'Footwear',\n  bags: 'Bags',\n  accessories: 'Accessories',\n  brands: 'Brands',\n  'new-in': 'New in',\n  sale: 'Sale',\n};\n"],"names":[],"mappings":";;;;AAAO,MAAM,kBAAkB;IAC7B,UAAU;IACV,YAAY;AACd;AAEO,MAAM,aAAa;IACxB,UAAU;IACV,UAAU;IACV,MAAM;IACN,aAAa;IACb,QAAQ;IACR,UAAU;IACV,MAAM;AACR"}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/data/footerLinks.ts"],"sourcesContent":["const links = {\n  customerServices: [\n    { label: 'FAQs', path: '#' },\n    { label: 'Track Order', path: '#' },\n    { label: 'Returns', path: '#' },\n    { label: 'Delivery', path: '#' },\n    { label: 'Payment', path: '#' },\n  ],\n  about: [\n    { label: 'About us', path: '#' },\n    { label: 'Blog', path: '#' },\n    { label: 'Privacy Policy', path: '#' },\n    { label: 'Terms & Conditions', path: '#' },\n  ],\n  connect: [\n    { label: 'Facebook', path: 'https://facebook.com' },\n    { label: 'Instagram', path: 'https://instagram.com' },\n    { label: 'LinekdIn', path: 'https://linkedin.com' },\n  ],\n};\n\nexport default links;\n"],"names":[],"mappings":";;;AAAA,MAAM,QAAQ;IACZ,kBAAkB;QAChB;YAAE,OAAO;YAAQ,MAAM;QAAI;QAC3B;YAAE,OAAO;YAAe,MAAM;QAAI;QAClC;YAAE,OAAO;YAAW,MAAM;QAAI;QAC9B;YAAE,OAAO;YAAY,MAAM;QAAI;QAC/B;YAAE,OAAO;YAAW,MAAM;QAAI;KAC/B;IACD,OAAO;QACL;YAAE,OAAO;YAAY,MAAM;QAAI;QAC/B;YAAE,OAAO;YAAQ,MAAM;QAAI;QAC3B;YAAE,OAAO;YAAkB,MAAM;QAAI;QACrC;YAAE,OAAO;YAAsB,MAAM;QAAI;KAC1C;IACD,SAAS;QACP;YAAE,OAAO;YAAY,MAAM;QAAuB;QAClD;YAAE,OAAO;YAAa,MAAM;QAAwB;QACpD;YAAE,OAAO;YAAY,MAAM;QAAuB;KACnD;AACH;uCAEe"}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/useGetAllSearchParams.ts"],"sourcesContent":["import { useSearchParams } from 'next/navigation';\n\nfunction useGetAllSearchParams() {\n  const searchParams = useSearchParams();\n\n  // Get all search params without sortby and page\n  const allSearchParams: { [anyProp: string]: string } = {};\n\n  searchParams.forEach((value, key) => {\n    if (key !== 'sortBy' && key !== 'page')\n      allSearchParams[key] = value;\n  });\n\n  // Get all filter params count\n  const count = Object.keys(allSearchParams)\n    .map((key) => allSearchParams[key].split(',').length)\n    .reduce((partialSum, a) => partialSum + a, 0);\n\n  return { allSearchParams, count };\n}\n\nexport default useGetAllSearchParams;\n"],"names":[],"mappings":";;;AAAA;;;AAEA,SAAS;;IACP,MAAM,eAAe,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD;IAEnC,gDAAgD;IAChD,MAAM,kBAAiD,CAAC;IAExD,aAAa,OAAO,CAAC,CAAC,OAAO;QAC3B,IAAI,QAAQ,YAAY,QAAQ,QAC9B,eAAe,CAAC,IAAI,GAAG;IAC3B;IAEA,8BAA8B;IAC9B,MAAM,QAAQ,OAAO,IAAI,CAAC,iBACvB,GAAG,CAAC,CAAC,MAAQ,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,MAAM,EACnD,MAAM,CAAC,CAAC,YAAY,IAAM,aAAa,GAAG;IAE7C,OAAO;QAAE;QAAiB;IAAM;AAClC;GAjBS;;QACc,qIAAA,CAAA,kBAAe;;;uCAkBvB"}},
    {"offset": {"line": 676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/useUpdateSearchParams.ts"],"sourcesContent":["import { usePathname, useRouter, useSearchParams } from \"next/navigation\"\n\nconst useUpdateSearchParams = () => {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  const pathname = usePathname()\n\n  const updateSearchParams = (field: string, value: string | null) => {\n    const updatedSearchParams = new URLSearchParams(searchParams.toString())\n    if (!value) {\n      updatedSearchParams.delete(field)\n    } else {\n      updatedSearchParams.set(field, value)\n    }\n\n    router.push(`${pathname}?${updatedSearchParams}`, {\n      scroll: false,\n    })\n  }\n\n  return updateSearchParams\n}\n\nexport default useUpdateSearchParams\n"],"names":[],"mappings":";;;AAAA;;;AAEA,MAAM,wBAAwB;;IAC5B,MAAM,SAAS,CAAA,GAAA,qIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,eAAe,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD;IACnC,MAAM,WAAW,CAAA,GAAA,qIAAA,CAAA,cAAW,AAAD;IAE3B,MAAM,qBAAqB,CAAC,OAAe;QACzC,MAAM,sBAAsB,IAAI,gBAAgB,aAAa,QAAQ;QACrE,IAAI,CAAC,OAAO;YACV,oBAAoB,MAAM,CAAC;QAC7B,OAAO;YACL,oBAAoB,GAAG,CAAC,OAAO;QACjC;QAEA,OAAO,IAAI,CAAC,GAAG,SAAS,CAAC,EAAE,qBAAqB,EAAE;YAChD,QAAQ;QACV;IACF;IAEA,OAAO;AACT;GAnBM;;QACW,qIAAA,CAAA,YAAS;QACH,qIAAA,CAAA,kBAAe;QACnB,qIAAA,CAAA,cAAW;;;uCAkBf"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/useFilters.tsx"],"sourcesContent":["import {\n  useRouter,\n  useSearchParams,\n} from 'next/navigation';\nimport useUpdateSearchParams from './useUpdateSearchParams';\n\nconst useFilters = (key: string) => {\n  const updateSearchParams = useUpdateSearchParams();\n  const searchParams = useSearchParams();\n  const router = useRouter();\n\n  // Get current filters\n  const params = searchParams.get(key) || '';\n  const filters = Array.from(\n    new Set(params.split(',').filter(Boolean))\n  );\n\n  // Set new value for filters\n  const updateFilters = (value: string) => {\n    const elementExists = Boolean(\n      filters.find((el) => el === value)\n    );\n\n    if (elementExists) {\n      updateSearchParams(\n        key,\n        `${filters.filter((el) => el !== value).join(',')}`\n      );\n    } else {\n      updateSearchParams(\n        key,\n        `${filters.join(',')}${\n          filters.length ? ',' : ''\n        }${value}`\n      );\n    }\n  };\n\n  // Check if filter is in array\n  const isFilterActive = (value: string) => {\n    const params = searchParams.get(key) || '';\n    const filters = Array.from(\n      new Set(params.split(',').filter(Boolean))\n    );\n\n    return Boolean(filters.find((el) => el === value));\n  };\n\n  // Clear all filters\n  const clearAllFilters = () => {\n    router.push(window.location.pathname, {\n      scroll: false,\n    });\n  };\n\n  return {\n    updateFilters,\n    filters,\n    isFilterActive,\n    clearAllFilters,\n  };\n};\n\nexport default useFilters;\n"],"names":[],"mappings":";;;AAAA;AAIA;;;;AAEA,MAAM,aAAa,CAAC;;IAClB,MAAM,qBAAqB,CAAA,GAAA,wIAAA,CAAA,UAAqB,AAAD;IAC/C,MAAM,eAAe,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD;IACnC,MAAM,SAAS,CAAA,GAAA,qIAAA,CAAA,YAAS,AAAD;IAEvB,sBAAsB;IACtB,MAAM,SAAS,aAAa,GAAG,CAAC,QAAQ;IACxC,MAAM,UAAU,MAAM,IAAI,CACxB,IAAI,IAAI,OAAO,KAAK,CAAC,KAAK,MAAM,CAAC;IAGnC,4BAA4B;IAC5B,MAAM,gBAAgB,CAAC;QACrB,MAAM,gBAAgB,QACpB,QAAQ,IAAI,CAAC,CAAC,KAAO,OAAO;QAG9B,IAAI,eAAe;YACjB,mBACE,KACA,GAAG,QAAQ,MAAM,CAAC,CAAC,KAAO,OAAO,OAAO,IAAI,CAAC,MAAM;QAEvD,OAAO;YACL,mBACE,KACA,GAAG,QAAQ,IAAI,CAAC,OACd,QAAQ,MAAM,GAAG,MAAM,KACtB,OAAO;QAEd;IACF;IAEA,8BAA8B;IAC9B,MAAM,iBAAiB,CAAC;QACtB,MAAM,SAAS,aAAa,GAAG,CAAC,QAAQ;QACxC,MAAM,UAAU,MAAM,IAAI,CACxB,IAAI,IAAI,OAAO,KAAK,CAAC,KAAK,MAAM,CAAC;QAGnC,OAAO,QAAQ,QAAQ,IAAI,CAAC,CAAC,KAAO,OAAO;IAC7C;IAEA,oBAAoB;IACpB,MAAM,kBAAkB;QACtB,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC,QAAQ,EAAE;YACpC,QAAQ;QACV;IACF;IAEA,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GAvDM;;QACuB,wIAAA,CAAA,UAAqB;QAC3B,qIAAA,CAAA,kBAAe;QACrB,qIAAA,CAAA,YAAS;;;uCAsDX"}},
    {"offset": {"line": 778, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 784, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/usePrevious.tsx"],"sourcesContent":["import { useRef, useEffect } from \"react\"\n\nexport function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>(value)\n  useEffect(() => {\n    ref.current = value\n  }, [value])\n  return ref.current\n}\n"],"names":[],"mappings":";;;AAAA;;;AAEO,SAAS,YAAe,KAAQ;;IACrC,MAAM,MAAM,CAAA,GAAA,6JAAA,CAAA,SAAM,AAAD,EAAK;IACtB,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;iCAAE;YACR,IAAI,OAAO,GAAG;QAChB;gCAAG;QAAC;KAAM;IACV,OAAO,IAAI,OAAO;AACpB;GANgB"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/useScreenSize.tsx"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nexport const useScreenSize = () => {\n  const [screenSize, setScreenSize] = useState<\n    'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' | ''\n  >('');\n\n  useEffect(() => {\n    const handleResize = () => {\n      if (window.innerWidth < 640) {\n        setScreenSize('xs');\n      } else if (\n        window.innerWidth >= 640 &&\n        window.innerWidth < 768\n      ) {\n        setScreenSize('sm');\n      } else if (\n        window.innerWidth >= 768 &&\n        window.innerWidth < 1024\n      ) {\n        setScreenSize('md');\n      } else if (\n        window.innerWidth >= 1024 &&\n        window.innerWidth < 1280\n      ) {\n        setScreenSize('lg');\n      } else if (\n        window.innerWidth >= 1280 &&\n        window.innerWidth < 1536\n      ) {\n        setScreenSize('xl');\n      } else if (window.innerWidth >= 1536) {\n        setScreenSize('2xl');\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    handleResize();\n\n    return () =>\n      window.removeEventListener('resize', handleResize);\n  }, []);\n\n  return screenSize;\n};\n"],"names":[],"mappings":";;;AAAA;;;AAEO,MAAM,gBAAgB;;IAC3B,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAEzC;IAEF,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;mCAAE;YACR,MAAM;wDAAe;oBACnB,IAAI,OAAO,UAAU,GAAG,KAAK;wBAC3B,cAAc;oBAChB,OAAO,IACL,OAAO,UAAU,IAAI,OACrB,OAAO,UAAU,GAAG,KACpB;wBACA,cAAc;oBAChB,OAAO,IACL,OAAO,UAAU,IAAI,OACrB,OAAO,UAAU,GAAG,MACpB;wBACA,cAAc;oBAChB,OAAO,IACL,OAAO,UAAU,IAAI,QACrB,OAAO,UAAU,GAAG,MACpB;wBACA,cAAc;oBAChB,OAAO,IACL,OAAO,UAAU,IAAI,QACrB,OAAO,UAAU,GAAG,MACpB;wBACA,cAAc;oBAChB,OAAO,IAAI,OAAO,UAAU,IAAI,MAAM;wBACpC,cAAc;oBAChB;gBACF;;YAEA,OAAO,gBAAgB,CAAC,UAAU;YAClC;YAEA;2CAAO,IACL,OAAO,mBAAmB,CAAC,UAAU;;QACzC;kCAAG,EAAE;IAEL,OAAO;AACT;GA1Ca"}},
    {"offset": {"line": 853, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 859, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/hooks/usePagination.tsx"],"sourcesContent":["import { useSearchParams } from 'next/navigation';\nimport useUpdateSearchParams from './useUpdateSearchParams';\n\nexport const usePagination = () => {\n  const searchParams = useSearchParams();\n  const updateSearchParams = useUpdateSearchParams();\n\n  const currentPage = parseInt(\n    searchParams.get('page') || '1'\n  );\n\n  const setPage = (page: string) => {\n    updateSearchParams('page', page);\n  };\n\n  return { currentPage, setPage };\n};\n"],"names":[],"mappings":";;;AAAA;AACA;;;;AAEO,MAAM,gBAAgB;;IAC3B,MAAM,eAAe,CAAA,GAAA,qIAAA,CAAA,kBAAe,AAAD;IACnC,MAAM,qBAAqB,CAAA,GAAA,wIAAA,CAAA,UAAqB,AAAD;IAE/C,MAAM,cAAc,SAClB,aAAa,GAAG,CAAC,WAAW;IAG9B,MAAM,UAAU,CAAC;QACf,mBAAmB,QAAQ;IAC7B;IAEA,OAAO;QAAE;QAAa;IAAQ;AAChC;GAba;;QACU,qIAAA,CAAA,kBAAe;QACT,wIAAA,CAAA,UAAqB"}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/const/index.ts"],"sourcesContent":["export const PRODUCT_LIMIT = 12\n\nexport const PARENT_CATEGORIES = [\"menswear\", \"womenswear\"]\n"],"names":[],"mappings":";;;;AAAO,MAAM,gBAAgB;AAEtB,MAAM,oBAAoB;IAAC;IAAY;CAAa"}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 913, "column": 0}, "map": {"version":3,"sources":["file:///root/webmakerr/storefront/src/app/not-found.tsx"],"sourcesContent":["import LocalizedClientLink from \"@/components/molecules/LocalizedLink/LocalizedLink\"\nimport { ArrowUpIcon } from \"@/icons\"\nimport { Metadata } from \"next\"\n\nexport const metadata: Metadata = {\n  title: \"404\",\n  description: \"Something went wrong\",\n}\n\nexport default function NotFound() {\n  return (\n    <div className=\"flex flex-col gap-4 items-center justify-center py-24\">\n      <h1 className=\"text-2xl-semi text-ui-fg-base\">Page not found</h1>\n      <p className=\"text-small-regular text-ui-fg-base\">\n        The page you tried to access does not exist.\n      </p>\n      <LocalizedClientLink className=\"flex gap-x-1 items-center group\" href=\"/\">\n        Go to frontpage\n        <ArrowUpIcon\n          className=\"group-hover:rotate-45 ease-in-out duration-150\"\n          color=\"var(--fg-interactive)\"\n        />\n      </LocalizedClientLink>\n    </div>\n  )\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;;;;AAGO,MAAM,WAAqB;IAChC,OAAO;IACP,aAAa;AACf;AAEe,SAAS;IACtB,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAG,WAAU;0BAAgC;;;;;;0BAC9C,6LAAC;gBAAE,WAAU;0BAAqC;;;;;;0BAGlD,6LAAC,oKAAA,CAAA,UAAmB;gBAAC,WAAU;gBAAkC,MAAK;;oBAAI;kCAExE,6LAAC,yHAAA,CAAA,cAAW;wBACV,WAAU;wBACV,OAAM;;;;;;;;;;;;;;;;;;AAKhB;KAhBwB"}},
    {"offset": {"line": 979, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}